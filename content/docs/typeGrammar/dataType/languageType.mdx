---
title: LanguageTypes
excerpt: LanguageTypes overview
date: 2023-01-23
type: Docs
category: DataType
tags: DataType
---

ECMAScript语言类型对应于ECMAScript程序员使用ECMAScript语言直接操作的值。
ECMAScript语言类型是`Undefined`、`Null`、`Boolean`、`String`、`Symbol`、`Number`、`BigInt`和`Object`。
ECMAScript语言值是以ECMAScript语言类型为特征的值。

## Undefined Type

Undefined类型恰好有一个值，称为**Undefined**。任何未分配值的变量都具有**Undefined**的值。

## Null Type

Null类型也只有一个值，称为**Null**

## Boolean Type

布尔类型表示一个具有两个值的逻辑实体，称为true和false。

## String Type

字符串类型是**零或多个16位Unicode**字符序列，最大长度为2<sup>53</sup> - 1个元素。

字符串类型通常用于表示正在运行的ECMAScript程序中的文本数据，在这种情况下，字符串中的每个元素都被视为[UTF-16](https://zh.wikipedia.org/wiki/UTF-16)代码单位值。
每个元素都被视为在序列中占据一个位置。这些位置用非负整数进行索引。
第一个元素（如果有的话）在索引0处，下一个元素（如果有的话）在索引1处，以此等。
字符串的长度是其中的元素数量（即16位值）。空字符串的长度为零，因此不包含任何元素。

更多可见[String Object](/docs/reference/text/string)

## Symbol Type

符号类型是所有非字符串值的集合，可以用作对象属性的键。

**每个可能的符号值都是唯一且不可变的。**

每个符号值不可变地包含一个名为`[[Description]]`的关联值，该值要么是`Undefined`，要么是`String`。

### Well-Know Symbols

众所周知的符号是内置的符号值，由ES规范的算法明确引用。

它们通常用作属性的键，其值作为ES规范算法的扩展点。除非另有说明，否则众所周知的符号值由所有[Realms]()共享。

在ES规范中，使用`@@name`形式的符号来引用一个众所周知的符号，其中“Name”是下表中列出的值之一。

| Specification Name |	[[Description]]	 | Value and Purpose |
| :------------ | :-------------- | :----------- |
| @@asyncIterator	| "Symbol.asyncIterator" |	返回对象默认AsyncIterator的方法。由for-await-of语句的语义调用。|
| @@hasInstance	  | "Symbol.hasInstance"	 |  一种确定构造函数对象是否将对象识别为构造函数实例之一的方法。由instanceof运算符的语义调用。|
| @@isConcatSpreadable	| "Symbol.isConcatSpreadable" |	一个布尔值属性，如果为真，则表示对象应由Array.prototype.concat将其扁平化为其数组元素。|
| @@iterator	    | "Symbol.iterator"	     |  返回对象默认Iterator的方法。由for-of语句的语义调用。 |
| @@match	        | "Symbol.match"	       |  将正则表达式与字符串匹配的正则表达式方法。由String.prototype.match方法调用。 |
| @@replace	      | "Symbol.replace"	     |  返回一个惯例的正则表达式方法，该方法产生正则表达式与字符串的匹配。由String.prototype.matchAll方法调用。|
| @@search	      | "Symbol.search"	       |  替换字符串匹配子字符串的正则表达式方法。由String.prototype.replace方法调用。|
| @@species	      | "Symbol.species"	     |  函数值属性，用于创建派生对象的构造函数。 |
| @@split	        | "Symbol.split"	       |  在与正则表达式匹配的索引处拆分字符串的正则表达式方法。由String.prototype.split方法调用。|
| @@toPrimitive	  | "Symbol.toPrimitive"	 |  将对象转换为相应原始值的方法。由ToPrimitive抽象操作调用。
| @@toStringTag	  | "Symbol.toStringTag"	 |  用于创建对象的默认字符串描述的字符串值属性。由内置方法Object.prototype.toString访问。|
| @@unscopables	  | "Symbol.unscopables"	 |  一个具有对象价值的属性，其自身和继承的属性名称是从关联对象的环境绑定中排除的属性名称。 |


## Numberic Types

ECMAScript有两种内置的数字类型：[Number](/operations/number)和BigInt。

以下抽象操作是在这些数字类型上定义的。“结果”列显示返回类型，并指示是否可能对操作的某些调用返回突然完成。

| Operation	                                    | Example source	| Invoked by the Evaluation semantics of ...	                            | Result                   |
| :-------------------------------------------- | :-------------- | :-----------------------------------------------------------------------| :----------------------- |
| Number::unaryMinus<br/>BigInt::unaryMinus	        | -x/~x           |  Unary - Operator	                                                      | Number/BigInt
| Number::bitwiseNOT<br/>BigInt::bitwiseNOT	        | ~x/~x           |  Bitwise NOT Operator ( ~ )	                                            | Number/BigInt
| Number::exponentiate<br/>BigInt::exponentiate	    | x ** y          |  Exponentiation Operator and Math.pow ( base, exponent )                | Number/either a normal completion containing a BigInt or a throw completion
| Number::multiply<br/>BigInt::multiply             | x * y           |  x * y	Multiplicative Operators                                        | Number/BigInt
| Number::divide<br/>BigInt::divide                 | x / y           |  Multiplicative Operators                                               | Number/either a normal completion containing a BigInt or a throw completion
| Number::remainder<br/>BigInt::remainder           | x % y           |  Multiplicative Operators	Number                                        | Number/either a normal completion containing a BigInt or a throw completion
| Number::add<br/>BigInt::add                       | x ++,++ x,x+y   |  Postfix/Prefix Increment Operator, and The Addition Operator ( + )	    | Number/BigInt
| Number::subtract<br/>BigInt::subtract             | x--,--x, x-y    |  Postfix/Prefix Increment Operator, and The Subtraction Operator ( - )	| Number/BigInt
| Number::leftShift<br/>BigInt::leftShift           |   `x << y`      |  The Left Shift Operator ( `<<` )	Number                                | Number/BigInt
| Number::signedRightShift<br/>BigInt::signedRightShift|   `x >> y`   |  The Signed Right Shift Operator ( >> )	Number                          | Number/BigInt
| Number::unsignedRightShift<br/>BigInt::unsignedRightShift|   `x >>> y`   |  The Unsigned Right Shift Operator ( >>> )	Number                  | Number/BigInt
| Number::unsignedRightShift<br/>BigInt::unsignedRightShift|   `x >>> y`   |  The Unsigned Right Shift Operator ( >>> )	Number                  | Number/a throw completion
| Number::lessThan<br/>BigInt::lessThan             | x < = y , x >= y |  Relational Operators, via IsLessThan ( x, y, LeftFirst )            	| Boolean or undefined (for unordered inputs)/Boolean
| Number::equal<br/>BigInt::equal                   | x == y x!=y      |  Equality Operators, via IsStrictlyEqual ( x, y )                      | Boolean
| Number::sameValue<br/>BigInt::sameValue           | Object.is(x, y)  | 	Object internal methods, via SameValue ( x, y ), to test exact value equality                      | Boolean
| Number::sameValueZero<br/>BigInt::sameValueZero   | [x].includes(y)  |  Array, Map, and Set methods, via SameValueZero ( x, y ), to test value equality, ignoring the difference between +0𝔽 and -0𝔽	                      | Boolean
| Number::bitwiseAND<br/>BigInt::bitwiseAND         | x & y            |  Binary Bitwise Operators                                              | Number/BigInt
| Number::bitwiseXOR<br/>BigInt::bitwiseXOR         | x ^ y            |  Binary Bitwise Operators                                              | Number/BigInt
| Number::bitwiseOR<br/>BigInt::bitwiseOR           | x | y            |  Binary Bitwise Operators                                              | Number/BigInt
| Number::toString<br/>BigInt::toString             | String(x)        |  Many expressions and built-in functions                               | String

由于数字类型通常不能在不损失精度或截断的情况下进行转换，因此ECMAScript语言在这些类型之间不提供隐式转换。
在调用需要另一种类型的函数时，程序员必须显式调用Number和BigInt函数才能在类型之间进行转换。

## Object Type

对象类型的每个实例，也简称为**对象**，代表属性的集合。 每个属性要么是*data property*数据属性，要么是*accessor property*访问器属性：

### Property attributes

- *data property*：将键值与ECMAScript语言值和一组布尔属性相关联。
  - *value*：通过属性的`get`访问，可以是任何ECMAScript语言值, **默认为undefined**。
  - *writable*：boolean值，表示属性值是否可写，默认**false**。
  - *enumerable*: boolean值，表示属性是否可枚举，使用`for...in`语句, 默认**false**。
  - *configurable*：boolean值，表示属性是否可配置，表示属性是否可以删除，可以更改访问器属性，是否可以更改其特性， 默认**false**。
- *accessor property*：将一个键值与一个或两个访问器函数以及一组布尔属性相关联。 访问器函数用于存储或检索与属性关联的ECMAScript语言值。
  - *get*：访问器函数，用于检索属性值，执行值的get访问时，使用一个空的参数列表表示调用函数获取属性值。
  - *set*：访问器函数，用于存储属性值， 执行值的set访问时，使用一个单个参数列表表示调用函数设置属性值。
  - *enumerable*: boolean值，表示属性是否可枚举，使用`for...in`语句。
  - *configurable*：boolean值，表示属性是否可配置，表示属性是否可以删除，可以更改访问器属性为数据属性或者数据属性为访问器属性，是否可以更改其特性。

对象的属性使用属性键进行唯一标识。*property keys*属性键要么是字符串(String)，要么是符号(Symbol)。所有字符串和符号，包括空字符串，都作为属性键有效。属性名称是字符串的属性键。

整数索引属性的范围是 +0 - 2<sup>53</sup> - 1 ，而数组的索引范围是+0 - 2<sup>53</sup> - 2。

`Property Keys`用于访问属性及其值。属性有两种访问：获取和设置，分别对应于值检索和赋值。
**通过*`get`*和*`set`*访问的属性既包括作为对象直接部分的自有属性，也包括由另一个关联对象通过属性继承关系提供的继承属性**。
继承的属性可以是关联对象的自己的或继承的属性。对象的每个自有属性都必须有一个与该对象的其他自有属性的键值不同的键值。

此外，一些对象是可调用的；这些被称为**函数或函数对象**。 ECMAScript中的所有函数都是对象类型的成员。

### Internal Methods And Internal Slots

在ECMAScript中，对象的实际语义是通过称为*Internal Methods*内部方法的算法指定的。 ECMAScript引擎中的**每个对象都与一组定义其运行时行为的内部方法相关联**。
这些内部方法不是ECMAScript语言的一部分(纯粹是为了说明的目的)。 然而，ECMAScript实现中的**每个对象都必须按照与其相关联的内部方法指定的方式运行**。

**内部方法名是多态的**。 这意味着当对不同的对象值调用公共的内部方法名时，它们可以执行不同的算法。
调用内部方法的实际对象是调用的“目标”。如果在运行时，算法的实现试图使用对象不支持的对象的内部方法，则会引发TypeError异常。

*Internal Slots*内部槽对应于与对象相关联并由各种ECMAScript规范算法使用的内部状态。
内部插槽不是对象属性，也不是继承的。根据特定的内部插槽规范，这种状态可以由任何ECMAScript语言类型的值或特定的ECMAScript规范类型值组成。除非另有明确规定，
否则内部插槽是作为创建对象过程的一部分分配的，并且不能动态地添加到对象中。除非另有说明，否则内部插槽的初始值是未定义的值。本规范中的各种算法创建具有内部槽的对象。
然而，ECMAScript语言没有提供将内部插槽与对象相关联的直接方法。
