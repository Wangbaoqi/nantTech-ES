# multiply/divide/reminder

## multiply

æŠ½è±¡æ“ä½œ `multiply` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚

è°ƒç”¨æ—¶ï¼Œå®ƒæ ¹æ®[IEEE 754-2019](https://tc39.es/ecma262/#sec-bibliography)äºŒè¿›åˆ¶åŒç²¾åº¦ç®—æœ¯çš„è§„åˆ™æ‰§è¡Œä¹˜æ³•ï¼Œäº§ç”Ÿ`x`å’Œ`y`çš„ä¹˜ç§¯ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

```md
1. If x is NaN or y is NaN, return NaN.
2. If x is either +âˆğ”½ or -âˆğ”½, then
  a. If y is either +0ğ”½ or -0ğ”½, return NaN.
  b. If y > +0ğ”½, return x.
  c. Return -x.
3. If y is either +âˆğ”½ or -âˆğ”½, then
  a. If x is either +0ğ”½ or -0ğ”½, return NaN.
  b. If x > +0ğ”½, return y.
  c. Return -y.
4. If x is -0ğ”½, then
  a. If y is -0ğ”½ or y < -0ğ”½, return +0ğ”½.
  b. Else, return -0ğ”½.
5. If y is -0ğ”½, then
  a. If x < -0ğ”½, return +0ğ”½.
  b. Else, return -0ğ”½.
6. Return ğ”½(â„(x) Ã— â„(y)).
```

```ts
export function multiply(x: number, y: number): boolean {
  if(isNaN(x) && isNaN(y)) return NaN;

  if(x === -Infinity || x === Infinity) {
    if(isNegativeZero(y as ESZeroType) || !isNegativeZero(y as ESZeroType)) return NaN;
    if(y > 0) return x;
    return -x
  }

  if(y === -Infinity || y === Infinity) {
    if(isNegativeZero(x as ESZeroType) || !isNegativeZero(x as ESZeroType)) return NaN;
    if(x > 0) return y;
    return -y
  }

  if(isNegativeZero(x as ESZeroType)) {
    if(isNegativeZero(y as ESZeroType) || y < 0) return 0;
    return -0
  }

  if(isNegativeZero(y as ESZeroType)) {
    if(isNegativeZero(x as ESZeroType) || x < 0) return 0;
    return -0
  }
  return x * y
}
```

## divide

æŠ½è±¡æ“ä½œ `divide` æ¥å—å‚æ•°`x(Number)`å’Œ`y(Number)`ï¼Œå¹¶è¿”å›ä¸€ä¸ªå¸ƒå°”å€¼ã€‚

è°ƒç”¨æ—¶ï¼Œå®ƒæ ¹æ®[IEEE 754-2019](https://tc39.es/ecma262/#sec-bibliography)äºŒè¿›åˆ¶åŒç²¾åº¦ç®—æœ¯çš„è§„åˆ™æ‰§è¡Œé™¤æ³•æ³•ï¼Œäº§ç”Ÿ`x`å’Œ`y`çš„å•†ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

```md
1. If x is NaN or y is NaN, return NaN.
2. If x is either +âˆğ”½ or -âˆğ”½, then
  a. If y is either +âˆğ”½ or -âˆğ”½, return NaN.
  b. If y is +0ğ”½ or y > +0ğ”½, return x.
  c. Return -x.
3. If y is +âˆğ”½, then
  a. If x is +0ğ”½ or x > +0ğ”½, return +0ğ”½. Otherwise, return -0ğ”½.
4. If y is -âˆğ”½, then
  a. If x is +0ğ”½ or x > +0ğ”½, return -0ğ”½. Otherwise, return +0ğ”½.
5. If x is either +0ğ”½ or -0ğ”½, then
  a. If y is either +0ğ”½ or -0ğ”½, return NaN.
  b. If y > +0ğ”½, return x.
  c. Return -x.
6. If y is +0ğ”½, then
  a. If x > +0ğ”½, return +âˆğ”½. Otherwise, return -âˆğ”½.
7. If y is -0ğ”½, then
  a. If x > +0ğ”½, return -âˆğ”½. Otherwise, return +âˆğ”½.
8. Return ğ”½(â„(x) / â„(y)).
```

```ts
export function divide(x: number, y: number): number {

  // 1. If x is NaN or y is NaN, return NaN.
  if(isNaN(x) && isNaN(y)) return NaN;

  if(x === -Infinity || x === Infinity) {
    if(y === -Infinity || y === Infinity) return NaN;
    if(y >= 0) return x;
    return -x
  }

  if(y === -Infinity) {
    if(!isNegativeZero(x as ESZeroType) || x > +0) return -0;
    return +0
  }

  if(y === Infinity) {
    if(!isNegativeZero(x as ESZeroType) || x > +0) return +0;
    return -0
  }

  if(isNegativeZero(x as ESZeroType) || !isNegativeZero(x as ESZeroType)) {
    if(isNegativeZero(y as ESZeroType) || !isNegativeZero(y as ESZeroType)) return NaN;
    if(y > +0) return x;
    return -x
  }

  // 1/0
  // -1/0
  if(!isNegativeZero(y as ESZeroType)) {
    if(x > 0) return +Infinity
    return -Infinity
  }

  // 1/-0
  // -1/-0
  if(isNegativeZero(y as ESZeroType)) {
    if(x > 0) return -Infinity
    return +Infinity
  }

  return x / y;
}
```

## reminder

æŠ½è±¡æ“ä½œ`remainder`æ¥å—å‚æ•°`n`å’Œ`d`ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰å¹¶è¿”å›ä¸€ä¸ªæ•°å­—ã€‚å®ƒä»å…¶æ“ä½œæ•°çš„éšå«é™¤æ³•ä¸­äº§ç”Ÿä½™æ•°ï¼Œå…¶ä¸­næ˜¯é™¤æ•°ï¼Œdæ˜¯é™¤æ•°ã€‚
è°ƒç”¨æ—¶ï¼Œå®ƒä¼šæ‰§è¡Œä»¥ä¸‹æ­¥éª¤ï¼š

```md
1. If n is NaN or d is NaN, return NaN.
2. If n is either +âˆğ”½ or -âˆğ”½, return NaN.
3. If d is either +âˆğ”½ or -âˆğ”½, return n.
4. If d is either +0ğ”½ or -0ğ”½, return NaN.
5. If n is either +0ğ”½ or -0ğ”½, return n.
6. Assert: n and d are finite and non-zero.
7. Let quotient be â„(n) / â„(d).
8. Let q be truncate(quotient).
9. Let r be â„(n) - (â„(d) Ã— q).
10. If r = 0 and n < -0ğ”½, return -0ğ”½.
11. Return ğ”½(r).
```

```ts
export function reminder(n: number, d: number): number {

  // 1. If n is NaN or d is NaN, return NaN.
  if(isNaN(n) || isNaN(d)) return NaN;

  if(n === Infinity || n === -Infinity) return NaN;

  if(d === Infinity || d === -Infinity) return n;

  if(isNegativeZero(d as ESZeroType) || !isNegativeZero(d as ESZeroType)) return NaN;

  if(isNegativeZero(n as ESZeroType) || !isNegativeZero(n as ESZeroType)) return n;

  if(n === 0 || d === 0 || !isFinite(d) || !isFinite(n)) {
    throw new Error('Assertion failed: n and d must be finite.')
  }

  let quotient = n / d;

  // æ•°å­¦å‡½æ•°æˆªæ–­ï¼ˆxï¼‰é€šè¿‡å‘é›¶å››èˆäº”å…¥å»é™¤xçš„åˆ†æ•°éƒ¨åˆ†ï¼Œå¦‚æœx < 0ï¼Œåˆ™äº§ç”Ÿ-floorï¼ˆ-xï¼‰ï¼Œå¦åˆ™äº§ç”Ÿfloorï¼ˆxï¼‰ã€‚
  let q = truncate(quotient);

  let r = n - (d * q);

  if(r === 0 && n < -0) return -0;

  return r;
}

// ç¬¦å·â€œx modulo yâ€ï¼ˆyå¿…é¡»æ˜¯æœ‰é™å’Œéé›¶ï¼‰è®¡ç®—ä¸yï¼ˆæˆ–é›¶ï¼‰ç›¸åŒç¬¦å·çš„å€¼kï¼Œ
// è¿™æ ·å¯¹äºä¸€äº›æ•´æ•°qï¼Œabs(k) < abs(y)å’Œx - k = q Ã— yã€‚
export function modulo(x: number, y: number) {
  // Step 1: Ensure y is finite and non-zero
  if (!Number.isFinite(y) || y === 0) {
    throw new Error("y must be finite and non-zero");
  }

  // Step 2: Calculate the remainder of the division of x by y
  let remainder = x % y;

  // Step 3: Adjust the result based on the sign of y
  if ((y > 0 && remainder < 0) || (y < 0 && remainder > 0)) {
    remainder += y;
  }

  return remainder;
}

export function floor(x: number) {
  return x - modulo(x, 1)
}

// æ•°å­¦å‡½æ•°æˆªæ–­ï¼ˆxï¼‰é€šè¿‡å‘é›¶å››èˆäº”å…¥å»é™¤xçš„åˆ†æ•°éƒ¨åˆ†ï¼Œå¦‚æœx < 0ï¼Œåˆ™äº§ç”Ÿ-floorï¼ˆ-xï¼‰ï¼Œå¦åˆ™äº§ç”Ÿfloorï¼ˆxï¼‰ã€‚
export function truncate(x: number) {
  if(x < 0) return -floor(-x);
  return floor(x);
}

```